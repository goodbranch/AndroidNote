## JAVA 虚拟机 2

## 编译jdk

* ![openJDK源码](https://jdk7.java.net/source.html)

### 编译源码需要步骤

#### 构建mac编译环境

* xcode 和Command Line Tool for XCode ,高于当前编译版本的jdk

* 

## 第2章 java 内存区域与内存溢出异常

### 运行时数据区域

![Java 虚拟机运行时数据区](JAVA_vm_data.jpeg)

* 程序计数器：一块较小的内存空间，他可以看做当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能。

	* 每个线程中都有独立的程序计数器

	* 如果正在执行的是Native方法区，那么当前程序计数值为空。

	* 此内存区域是JAVA唯一一个没有规范任何OutOfMemory情况的区域。

* JAVA虚拟机栈：JAVA方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息，每一个方法从调用直到执行完成的过程就对应着一个栈帧在虚拟机中入栈到出栈的过程。

	* 线程私有

	* 生命周期与线程一样

	* 局部变量表：各种基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用(refrence类型，它不等于对象本身，而是指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其它与此对象相关的位置)和returnAddress类型（指向一条字节码指令的返回地址）

	* 局部变量表锁需要的内存区域空间在编译期间完成分配。

	* 会抛出OutOfMemory和StackOverFlowError错误


* 本地方法栈：与虚拟机栈基本一样，唯一不同的是本地方法指的是native方法

* Java堆：是所有线程共享的一块内存区域，此内存唯一的目的是存放对象实例。

	* 虚拟机启动时创建。

	* JAVA虚拟机所管理的内存中最大的一块。

	* 是内存垃圾回收器管理的主要区域。

		* JAVA内存回收采用分代收集算法，所以JAVA堆中还可以细分为，新生代，老年代，在细致一点油Eden空间，From Survivor，to Survivor空间等

	* 内存分配逻辑上连续但物理上不一定连续。

* 方法区：用于存储已被虚拟机加载的类信息，常量，静态变量，及时编译器编译后的代码等数据。

	* 线程共享内存

	* 比较复杂的GC操作

	* 1.7 hotspot 已经把放在永久代的字符串常量移出。

* 运行时常量：Class 文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量，和符号引用。

	* 


### HotSpot 虚拟机对象探秘

* 




